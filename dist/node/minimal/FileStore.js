"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStore = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
// File-based storage manager
class FileStore {
    constructor(dataDir) {
        this.writeQueue = new Map();
        this.dataDir = dataDir;
    }
    async initialize() {
        try {
            await fs_1.promises.mkdir(this.dataDir, { recursive: true });
        }
        catch (error) {
            throw new Error(`Failed to create data directory: ${error.message}`);
        }
    }
    getFilePath(filename) {
        return (0, path_1.join)(this.dataDir, `${filename}.json`);
    }
    async read(filename) {
        try {
            const filePath = this.getFilePath(filename);
            const data = await fs_1.promises.readFile(filePath, "utf8");
            return JSON.parse(data);
        }
        catch (error) {
            if (error.code === "ENOENT")
                return null;
            throw new Error(`Failed to read file ${filename}: ${error.message}`);
        }
    }
    async write(filename, data) {
        const filePath = this.getFilePath(filename);
        // Queue writes to prevent concurrent file access
        const writeOperation = async () => {
            try {
                const jsonData = JSON.stringify(data || {}, null, 2);
                await fs_1.promises.writeFile(filePath, jsonData, "utf8");
            }
            catch (error) {
                throw new Error(`Failed to write file ${filename}: ${error.message}`);
            }
        };
        // Add to queue and wait for completion
        const currentWrite = this.writeQueue.get(filename) || Promise.resolve();
        const nextWrite = currentWrite.then(writeOperation);
        this.writeQueue.set(filename, nextWrite);
        await nextWrite;
    }
}
exports.FileStore = FileStore;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZVN0b3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL21pbmltYWwvRmlsZVN0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJCQUFvQztBQUNwQywrQkFBNEI7QUFFNUIsNkJBQTZCO0FBQzdCLE1BQWEsU0FBUztJQUlwQixZQUFZLE9BQWU7UUFGbkIsZUFBVSxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBR3pELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxLQUFLLENBQUMsVUFBVTtRQUNkLElBQUksQ0FBQztZQUNILE1BQU0sYUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUFDLE9BQU8sS0FBVSxFQUFFLENBQUM7WUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDdkUsQ0FBQztJQUNILENBQUM7SUFFTyxXQUFXLENBQUMsUUFBZ0I7UUFDbEMsT0FBTyxJQUFBLFdBQUksRUFBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsUUFBUSxPQUFPLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsS0FBSyxDQUFDLElBQUksQ0FBSSxRQUFnQjtRQUM1QixJQUFJLENBQUM7WUFDSCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sSUFBSSxHQUFHLE1BQU0sYUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDakQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBTSxDQUFDO1FBQy9CLENBQUM7UUFBQyxPQUFPLEtBQVUsRUFBRSxDQUFDO1lBQ3BCLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxRQUFRO2dCQUFFLE9BQU8sSUFBSSxDQUFDO1lBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLFFBQVEsS0FBSyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUN2RSxDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUssQ0FBQyxLQUFLLENBQUksUUFBZ0IsRUFBRSxJQUFPO1FBQ3RDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFNUMsaURBQWlEO1FBQ2pELE1BQU0sY0FBYyxHQUFHLEtBQUssSUFBSSxFQUFFO1lBQ2hDLElBQUksQ0FBQztnQkFDSCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxNQUFNLGFBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUNqRCxDQUFDO1lBQUMsT0FBTyxLQUFVLEVBQUUsQ0FBQztnQkFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsUUFBUSxLQUFLLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ3hFLENBQUM7UUFDSCxDQUFDLENBQUM7UUFFRix1Q0FBdUM7UUFDdkMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3hFLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3pDLE1BQU0sU0FBUyxDQUFDO0lBQ2xCLENBQUM7Q0FDRjtBQWxERCw4QkFrREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XG5cbi8vIEZpbGUtYmFzZWQgc3RvcmFnZSBtYW5hZ2VyXG5leHBvcnQgY2xhc3MgRmlsZVN0b3JlIHtcbiAgcHJpdmF0ZSBkYXRhRGlyOiBzdHJpbmc7XG4gIHByaXZhdGUgd3JpdGVRdWV1ZTogTWFwPHN0cmluZywgUHJvbWlzZTx2b2lkPj4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoZGF0YURpcjogc3RyaW5nKSB7XG4gICAgdGhpcy5kYXRhRGlyID0gZGF0YURpcjtcbiAgfVxuXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLm1rZGlyKHRoaXMuZGF0YURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGRhdGEgZGlyZWN0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRGaWxlUGF0aChmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gam9pbih0aGlzLmRhdGFEaXIsIGAke2ZpbGVuYW1lfS5qc29uYCk7XG4gIH1cblxuICBhc3luYyByZWFkPFQ+KGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5nZXRGaWxlUGF0aChmaWxlbmFtZSk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpIGFzIFQ7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHJldHVybiBudWxsO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCBmaWxlICR7ZmlsZW5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgd3JpdGU8VD4oZmlsZW5hbWU6IHN0cmluZywgZGF0YTogVCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5nZXRGaWxlUGF0aChmaWxlbmFtZSk7XG5cbiAgICAvLyBRdWV1ZSB3cml0ZXMgdG8gcHJldmVudCBjb25jdXJyZW50IGZpbGUgYWNjZXNzXG4gICAgY29uc3Qgd3JpdGVPcGVyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uRGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEgfHwge30sIG51bGwsIDIpO1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIGpzb25EYXRhLCBcInV0ZjhcIik7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHdyaXRlIGZpbGUgJHtmaWxlbmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQWRkIHRvIHF1ZXVlIGFuZCB3YWl0IGZvciBjb21wbGV0aW9uXG4gICAgY29uc3QgY3VycmVudFdyaXRlID0gdGhpcy53cml0ZVF1ZXVlLmdldChmaWxlbmFtZSkgfHwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgbmV4dFdyaXRlID0gY3VycmVudFdyaXRlLnRoZW4od3JpdGVPcGVyYXRpb24pO1xuICAgIHRoaXMud3JpdGVRdWV1ZS5zZXQoZmlsZW5hbWUsIG5leHRXcml0ZSk7XG4gICAgYXdhaXQgbmV4dFdyaXRlO1xuICB9XG59XG4iXX0=