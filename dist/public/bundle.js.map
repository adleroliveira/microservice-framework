{
  "version": 3,
  "sources": ["../../node_modules/eventemitter3/index.js", "../../src/browser/index.ts", "../../node_modules/eventemitter3/index.mjs", "../../node_modules/uuid/dist/esm-browser/rng.js", "../../node_modules/uuid/dist/esm-browser/regex.js", "../../node_modules/uuid/dist/esm-browser/validate.js", "../../node_modules/uuid/dist/esm-browser/stringify.js", "../../node_modules/uuid/dist/esm-browser/v4.js", "../../src/logging/LogStrategy.ts", "../../src/browser/BrowserConsoleStrategy.ts", "../../src/browser/WebSocketManager.ts", "../../src/browser/RequestManager.ts", "../../src/browser/CommunicationsManager.ts"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "export * from \"./WebSocketManager\";\nexport * from \"./BrowserConsoleStrategy\";\nexport * from \"./CommunicationsManager\";\nexport * from \"./WebSocketManager\";\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;", "import { IRequest, IRequestHeader } from \"../interfaces\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\n/**\n * Type representing the payload type of a log message.\n */\nexport type PayloadType = \"text\" | \"json\";\n\n/**\n * Interface representing the payload of a log message.\n */\nexport interface LogPayload {\n  /** The type of the payload. */\n  type: PayloadType;\n  /** The content of the payload. */\n  content: string | object;\n}\n\n/**\n * Interface representing a log message.\n */\nexport interface LogMessage {\n  sender?: string;\n  /** The timestamp of the log message. */\n  timestamp: string;\n  /** The log level of the message. */\n  level: string;\n  /** The content of the log message. */\n  message: string;\n  /** Optional payload for additional information. */\n  payload?: LogPayload;\n}\n\nexport abstract class LogStrategy {\n  protected MAX_STRING_LENGTH?: number;\n  protected MAX_DEPTH?: number;\n  protected abstract sendPackaged(\n    packagedMessage: IRequest<any>,\n    options?: Record<string, any>\n  ): Promise<void>;\n\n  constructor() {}\n\n  async send(message: any, options?: Record<string, any>): Promise<void> {\n    const truncatedMessage = LogStrategy.truncateAndStringify(\n      message,\n      0,\n      this.MAX_STRING_LENGTH,\n      this.MAX_DEPTH\n    );\n\n    const packagedMessage: IRequest<any> = {\n      header: this.createRequestHeader(),\n      body: truncatedMessage,\n    };\n\n    await this.sendPackaged(packagedMessage, options);\n  }\n\n  protected createRequestHeader(): IRequestHeader {\n    return {\n      timestamp: Date.now(),\n      requestId: uuidv4(),\n      requesterAddress: \"log-strategy\",\n      requestType: \"LOG::MESSAGE\",\n    };\n  }\n\n  static truncateAndStringify(\n    value: any,\n    depth: number = 0,\n    maxStringLength = 5000,\n    maxDepth = 10\n  ): any {\n    if (depth > maxDepth) {\n      return \"[Object depth limit exceeded]\";\n    }\n\n    if (value === undefined || value === null) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.length > maxStringLength\n        ? value.substring(0, maxStringLength) + \"...\"\n        : value;\n    }\n\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      return value;\n    }\n\n    if (value instanceof Error) {\n      return {\n        name: value.name,\n        message: this.truncateAndStringify(value.message),\n        stack: this.truncateAndStringify(value.stack),\n      };\n    }\n\n    if (this.isBufferOrArrayBufferView(value)) {\n      return `[Binary data of length ${value.byteLength}]`;\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((item) => this.truncateAndStringify(item, depth + 1));\n    }\n\n    if (typeof value === \"object\") {\n      const truncatedObject: { [key: string]: any } = {};\n      for (const [key, prop] of Object.entries(value)) {\n        truncatedObject[key] = this.truncateAndStringify(prop, depth + 1);\n      }\n      return truncatedObject;\n    }\n\n    return \"[Unserializable data]\";\n  }\n\n  private static isBufferOrArrayBufferView(value: any): boolean {\n    // Check for Buffer in Node.js environment\n    if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(value)) {\n      return true;\n    }\n\n    // Check for ArrayBuffer view in browser environment\n    if (ArrayBuffer.isView(value)) {\n      return true;\n    }\n\n    // Check if value is an ArrayBuffer\n    if (value instanceof ArrayBuffer) {\n      return true;\n    }\n\n    return false;\n  }\n}\n", "import { IRequest } from \"../interfaces\";\nimport { LogLevel, LogMessage, LogStrategy } from \"../logging/LogStrategy\";\n\nexport class BrowserConsoleStrategy extends LogStrategy {\n  private static readonly LOG_COLORS = {\n    [LogLevel.INFO]: \"color: blue\",\n    [LogLevel.WARN]: \"color: orange\",\n    [LogLevel.ERROR]: \"color: red\",\n    [LogLevel.DEBUG]: \"color: green\",\n  };\n\n  constructor(maxStringLength = 5000, maxDepth = 10) {\n    super();\n    this.MAX_STRING_LENGTH = maxStringLength;\n    this.MAX_DEPTH = maxDepth;\n  }\n\n  private isLogMessage(body: any): body is LogMessage {\n    return (\n      typeof body === \"object\" &&\n      body !== null &&\n      \"timestamp\" in body &&\n      \"level\" in body &&\n      \"message\" in body\n    );\n  }\n\n  protected async sendPackaged(\n    packagedMessage: IRequest<any>,\n    options?: Record<string, any>\n  ): Promise<void> {\n    const { header, body } = packagedMessage;\n    const logLevel = (options?.logLevel as LogLevel) || LogLevel.INFO;\n\n    if (this.isLogMessage(body)) {\n      this.formatLogMessage(body, header.requestId);\n    } else {\n      this.formatGenericMessage(\n        body,\n        logLevel,\n        header.timestamp,\n        header.requestId\n      );\n    }\n  }\n\n  private formatLogMessage(logMessage: LogMessage, requestId: string): void {\n    const { sender, timestamp, level, message, payload } = logMessage;\n    const logLevel = (parseInt(level) as LogLevel) || LogLevel.INFO;\n    const color = BrowserConsoleStrategy.LOG_COLORS[logLevel];\n\n    console.groupCollapsed(\n      `%c[${logLevel}] ${new Date(timestamp).toISOString()}`,\n      color\n    );\n\n    if (sender) {\n      console.log(`Sender: ${sender}`);\n    }\n    console.log(`Message: ${message}`);\n    console.log(`RequestID: ${requestId}`);\n\n    if (payload) {\n      console.log(\"Payload:\", payload);\n    }\n\n    console.groupEnd();\n  }\n\n  private formatGenericMessage(\n    message: any,\n    logLevel: LogLevel,\n    timestamp: number,\n    requestId: string\n  ): void {\n    const color = BrowserConsoleStrategy.LOG_COLORS[logLevel];\n\n    console.groupCollapsed(\n      `%c[${logLevel}] ${new Date(timestamp).toISOString()}`,\n      color\n    );\n\n    console.log(`RequestID: ${requestId}`);\n\n    if (typeof message === \"object\" && message !== null) {\n      console.log(\"Message:\", message);\n    } else {\n      console.log(`Message: ${message}`);\n    }\n\n    console.groupEnd();\n  }\n\n  async log(message: any, logLevel: LogLevel = LogLevel.INFO): Promise<void> {\n    await this.send(message, { logLevel });\n  }\n\n  async info(message: any, data?: any): Promise<void> {\n    await this.log({ message, data }, LogLevel.INFO);\n  }\n\n  async warn(message: any, data?: any): Promise<void> {\n    await this.log({ message, data }, LogLevel.WARN);\n  }\n\n  async error(message: any, data?: any): Promise<void> {\n    await this.log({ message, data }, LogLevel.ERROR);\n  }\n\n  async debug(message: any, data?: any): Promise<void> {\n    await this.log({ message, data }, LogLevel.DEBUG);\n  }\n}\n", "import EventEmitter from \"eventemitter3\";\nimport { BrowserConsoleStrategy } from \"./BrowserConsoleStrategy\";\n\nexport enum WebSocketState {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED,\n}\n\nexport enum AuthMethod {\n  TOKEN = \"token\",\n  CREDENTIALS = \"credentials\",\n  ANONYMOUS = \"anonymous\",\n}\n\nexport interface IWebSocketAuthConfig {\n  method: AuthMethod;\n  token?: string;\n  credentials?: {\n    username: string;\n    password: string;\n  };\n}\n\nexport interface IWebSocketManagerConfig {\n  url: string;\n  secure?: boolean;\n  auth?: IWebSocketAuthConfig;\n  maxReconnectAttempts?: number;\n  reconnectInterval?: number;\n  connectionTimeout?: number;\n}\n\nexport class WebSocketManager extends EventEmitter {\n  private logger: BrowserConsoleStrategy;\n  private ws!: WebSocket;\n  private url: string;\n  private secure: boolean;\n  private auth?: IWebSocketAuthConfig;\n  private reconnectAttempts: number = 0;\n  private maxReconnectAttempts: number;\n  private reconnectInterval: number;\n  private state: WebSocketState = WebSocketState.CLOSED;\n  private connectionTimeout: number;\n  private connectionTimer?: number;\n  private protocols: string[] = [];\n\n  constructor(config: IWebSocketManagerConfig) {\n    super();\n    this.logger = new BrowserConsoleStrategy();\n    this.url = config.url;\n    this.secure = config.secure || false;\n    this.auth = config.auth;\n    this.maxReconnectAttempts = config.maxReconnectAttempts || 5;\n    this.reconnectInterval = config.reconnectInterval || 5000;\n    this.connectionTimeout = config.connectionTimeout || 10000;\n\n    this.setupAuthProtocols();\n    this.connect();\n  }\n\n  private setupAuthProtocols() {\n    if (!this.auth) return;\n    switch (this.auth.method) {\n      case AuthMethod.TOKEN:\n        if (this.auth.token) {\n          this.protocols.push(`token-${this.auth.token}`);\n        }\n        break;\n      case AuthMethod.CREDENTIALS:\n        if (this.auth.credentials) {\n          const { username, password } = this.auth.credentials;\n          const credentials = btoa(encodeURIComponent(password)).replace(\n            /=/g,\n            \"\"\n          );\n          this.protocols.push(`auth-${username}-${credentials}`);\n          this.logger.debug(`Auth protocol`, this.protocols);\n        }\n        break;\n    }\n  }\n\n  private connect() {\n    this.state = WebSocketState.CONNECTING;\n\n    const secureUrl = this.getSecureUrl(this.url, this.secure);\n\n    // Add token to URL if using query parameter authentication\n    const urlWithAuth =\n      this.auth?.method === AuthMethod.TOKEN && this.auth.token\n        ? `${secureUrl}?token=${this.auth.token}`\n        : secureUrl;\n\n    this.logger.info(`Attempting to connect to ${urlWithAuth}`);\n    try {\n      this.ws = new WebSocket(urlWithAuth, this.protocols);\n      this.setHooks();\n      this.setConnectionTimeout();\n    } catch (error) {\n      this.handleConnectionError(error);\n    }\n  }\n\n  private handleConnectionError(error: any) {\n    this.logger.error(\"Connection error:\", error);\n    this.emit(\"error\", {\n      type: \"CONNECTION_ERROR\",\n      message: \"Failed to establish WebSocket connection\",\n      error,\n    });\n  }\n\n  private getSecureUrl(url: string, secure: boolean): string {\n    return secure ? url.replace(/^ws:/, \"wss:\") : url;\n  }\n\n  private setHooks() {\n    this.ws.onopen = () => {\n      this.clearConnectionTimeout();\n      this.state = WebSocketState.OPEN;\n      this.reconnectAttempts = 0;\n      this.logger.info(`WebSocket opened. ReadyState: ${this.ws.readyState}`);\n      this.emit(\"open\");\n    };\n\n    this.ws.onerror = (error: Event) => {\n      const wsError = error.target as WebSocket;\n\n      if (wsError.readyState === WebSocket.CLOSED) {\n        const errorDetails = {\n          type: \"CONNECTION_ERROR\",\n          message: \"Connection failed\",\n          readyState: wsError.readyState,\n          url: wsError.url,\n        };\n\n        if (this.reconnectAttempts === 0) {\n          // First connection attempt failed immediately - likely auth failure\n          errorDetails.type = \"AUTH_ERROR\";\n          errorDetails.message = \"Authentication required\";\n        }\n\n        this.logger.error(\"WebSocket error:\", errorDetails);\n        this.emit(\"error\", errorDetails);\n      } else {\n        this.logger.error(\"WebSocket error:\", error);\n        this.emit(\"error\", error);\n      }\n    };\n\n    this.ws.onclose = (event) => {\n      this.clearConnectionTimeout();\n      this.state = WebSocketState.CLOSED;\n\n      // Handle all potential authentication-related close codes\n      if (\n        event.code === 1001 || // Going Away\n        event.code === 1006 || // Abnormal Closure (what browsers often use for 401)\n        event.code === 1008\n      ) {\n        // Policy Violation\n        const error = {\n          type: \"AUTH_ERROR\",\n          code: event.code,\n          reason: event.reason || \"Authentication required\",\n        };\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.logger.info(\n        `WebSocket closed. ReadyState: ${this.ws.readyState}. Code: ${event.code}, Reason: ${event.reason}`\n      );\n      this.emit(\"close\", event);\n      this.handleReconnection();\n    };\n\n    this.ws.onmessage = (event) => {\n      const parsedData = this.parseMessage(event.data);\n      this.emit(\"message\", parsedData);\n    };\n  }\n\n  private handleReconnection() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const minDelay = 1000;\n      const delay = Math.max(\n        minDelay,\n        this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1)\n      );\n      this.logger.info(\n        `Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`\n      );\n      setTimeout(() => this.connect(), delay);\n    } else {\n      this.logger.error(\n        \"Max reconnection attempts reached. Please reconnect manually.\"\n      );\n      this.emit(\"maxReconnectAttemptsReached\");\n    }\n  }\n\n  private setConnectionTimeout() {\n    this.connectionTimer = window.setTimeout(() => {\n      if (this.state === WebSocketState.CONNECTING) {\n        this.logger.error(\"Connection attempt timed out\");\n        this.ws.close();\n      }\n    }, this.connectionTimeout);\n  }\n\n  private clearConnectionTimeout() {\n    if (this.connectionTimer) {\n      window.clearTimeout(this.connectionTimer);\n    }\n  }\n\n  private parseMessage(data: any): any {\n    try {\n      return JSON.parse(data);\n    } catch (error) {\n      return data;\n    }\n  }\n\n  public send(message: string | object) {\n    if (this.state === WebSocketState.OPEN) {\n      const data =\n        typeof message === \"string\" ? message : JSON.stringify(message);\n      this.ws.send(data);\n    } else {\n      const error = new Error(\"WebSocket is not open\");\n      this.emit(\"error\", error);\n    }\n  }\n\n  public close() {\n    this.state = WebSocketState.CLOSING;\n    this.ws.close();\n  }\n\n  public reconnect() {\n    this.logger.debug(\"Manual reconnection initiated.\");\n    this.reconnectAttempts = 0;\n    this.close();\n    this.connect();\n  }\n\n  public getState(): WebSocketState {\n    return this.state;\n  }\n\n  public getReadyState(): number {\n    return this.ws.readyState;\n  }\n\n  public setAuthConfig(authConfig: IWebSocketAuthConfig) {\n    this.auth = authConfig;\n    this.setupAuthProtocols();\n  }\n\n  public isAuthenticated(): boolean {\n    return this.state === WebSocketState.OPEN;\n  }\n\n  public reconnectWithNewAuth(authConfig: IWebSocketAuthConfig) {\n    this.setAuthConfig(authConfig);\n    this.reconnect();\n  }\n\n  public destroy(): void {\n    // Clear the connection timeout if it exists\n    this.clearConnectionTimeout();\n\n    // Close WebSocket connection if it exists\n    if (this.ws) {\n      // Remove all WebSocket event listeners\n      this.ws.onopen = null;\n      this.ws.onclose = null;\n      this.ws.onerror = null;\n      this.ws.onmessage = null;\n\n      // Close the connection if it's not already closed\n      if (this.state !== WebSocketState.CLOSED) {\n        this.close();\n      }\n\n      this.ws = null!;\n    }\n\n    // Clear all event listeners\n    this.removeAllListeners();\n\n    // Clear references\n    this.logger = null!;\n    this.auth = undefined;\n    this.protocols = [];\n  }\n}\n", "import { v4 as uuidv4 } from \"uuid\";\nimport {\n  IRequest,\n  IResponse,\n  IResponseData,\n  IRequestHeader,\n} from \"../interfaces\";\nimport EventEmitter from \"eventemitter3\";\nimport { WebSocketManager } from \"./WebSocketManager\";\nimport { BrowserConsoleStrategy } from \"./BrowserConsoleStrategy\";\n\nexport interface RequestManagerProps {\n  webSocketManager: WebSocketManager;\n  requestTimeout?: number;\n}\n\ntype RequestHandler<T, R> = (\n  payload: T,\n  requestHeader: IRequestHeader\n) => Promise<R> | R;\n\nexport class RequestManager extends EventEmitter {\n  private logger: BrowserConsoleStrategy;\n  private pendingRequests: Map<string, (response: IResponse<any>) => void> =\n    new Map();\n  private requestHandlers: Map<string, RequestHandler<any, any>> = new Map();\n  private requestTimeout: number;\n  private webSocketManager: WebSocketManager;\n  private authToken: string | undefined;\n\n  constructor(props: RequestManagerProps) {\n    super();\n    this.logger = new BrowserConsoleStrategy();\n    this.requestTimeout = props.requestTimeout || 30000;\n    this.webSocketManager = props.webSocketManager;\n    this.webSocketManager.on(\"message\", this.handleMessage.bind(this));\n  }\n\n  public async request<I, O>(\n    requestType: string,\n    body: I,\n    to?: string\n  ): Promise<IResponseData<O>> {\n    return new Promise((resolve, reject) => {\n      const request = this.createRequest<I>(requestType, body, to);\n      const timeoutId = setTimeout(() => {\n        this.pendingRequests.delete(request.header.requestId);\n        reject(new Error(\"Request timeout\"));\n      }, this.requestTimeout);\n\n      const requestCallback = (response: IResponse<O>) => {\n        clearTimeout(timeoutId);\n        this.pendingRequests.delete(request.header.requestId);\n        if (response.body.success) {\n          resolve(response.body);\n        } else {\n          reject(response.body.error || response.body.data);\n        }\n      };\n\n      this.pendingRequests.set(request.header.requestId, requestCallback);\n      this.webSocketManager.send(JSON.stringify(request));\n    });\n  }\n\n  private createRequest<T>(\n    requestType: string,\n    body: T,\n    to?: string\n  ): IRequest<T> {\n    return {\n      header: {\n        timestamp: Date.now(),\n        requestId: `RM-${uuidv4()}`,\n        requesterAddress: \"RequestManager\",\n        recipientAddress: to,\n        requestType,\n        authToken: this.authToken,\n      },\n      body,\n    };\n  }\n\n  private handleMessage(parsed: any) {\n    try {\n      if (parsed.header && parsed.header.requestType) {\n        this.handleIncomingRequest(parsed);\n      } else if (parsed.requestHeader) {\n        this.handleResponse(parsed);\n      } else {\n        this.logger.warn(\"Received message with unknown structure:\", parsed);\n      }\n    } catch (error) {\n      this.logger.error(\"Error parsing message:\", error);\n    }\n  }\n\n  private async handleIncomingRequest(request: IRequest<any>) {\n    const { requestType } = request.header;\n\n    if (!requestType) {\n      this.logger.warn(\"Received request without requestType\");\n      return;\n    }\n\n    if (this.listenerCount(requestType) > 0) {\n      // Pass both payload and header to ensure we can construct the response\n      this.emit(requestType, request.body, request.header);\n    } else {\n      this.logger.warn(\n        `No handlers registered for requestType: ${requestType}`\n      );\n\n      // Send error response for unhandled request types\n      const errorResponse: IResponse<null> = {\n        requestHeader: request.header,\n        responseHeader: {\n          responderAddress: \"RequestManager\",\n          timestamp: Date.now(),\n        },\n        body: {\n          data: null,\n          success: false,\n          error: new Error(\n            `No handler registered for requestType: ${requestType}`\n          ),\n        },\n      };\n      this.webSocketManager.send(JSON.stringify(errorResponse));\n    }\n  }\n\n  private handleResponse<T>(response: IResponse<T>) {\n    const pendingRequest = this.pendingRequests.get(\n      response.requestHeader.requestId\n    );\n    if (pendingRequest) {\n      pendingRequest(response);\n      this.pendingRequests.delete(response.requestHeader.requestId);\n    }\n  }\n\n  // Method to register handlers for incoming requests\n  public registerHandler<T, R>(\n    requestType: string,\n    handler: (payload: T, requestHeader: IRequestHeader) => Promise<R> | R\n  ): void {\n    if (this.requestHandlers.has(requestType)) {\n      throw new Error(\n        `Handler already registered for requestType: ${requestType}`\n      );\n    }\n\n    this.requestHandlers.set(requestType, handler);\n\n    // Set up the event listener that ensures responses go back through WebSocket\n    this.on(requestType, async (payload: T, requestHeader: IRequestHeader) => {\n      try {\n        const result = await handler(payload, requestHeader);\n        const response: IResponse<R> = {\n          requestHeader,\n          responseHeader: {\n            responderAddress: \"RequestManager\",\n            timestamp: Date.now(),\n          },\n          body: {\n            data: result,\n            success: true,\n            error: null,\n          },\n        };\n        this.webSocketManager.send(JSON.stringify(response));\n      } catch (error) {\n        const errorResponse: IResponse<null> = {\n          requestHeader,\n          responseHeader: {\n            responderAddress: \"RequestManager\",\n            timestamp: Date.now(),\n          },\n          body: {\n            data: null,\n            success: false,\n            error: error instanceof Error ? error : new Error(String(error)),\n          },\n        };\n        this.webSocketManager.send(JSON.stringify(errorResponse));\n      }\n    });\n  }\n\n  // Method to remove handlers\n  public removeHandler(requestType: string): void {\n    this.requestHandlers.delete(requestType);\n    this.removeAllListeners(requestType);\n  }\n\n  public setAuthToken(token: string) {\n    this.authToken = token;\n  }\n\n  public clearAuthToken() {\n    this.authToken = undefined;\n  }\n\n  public clearState(): void {\n    // Clear pending requests but keep the manager alive\n    for (const [requestId] of this.pendingRequests) {\n      this.pendingRequests.delete(requestId);\n    }\n    this.clearAuthToken();\n  }\n\n  public destroy(): void {\n    // Clear timeout for any pending requests\n    for (const [requestId] of this.pendingRequests) {\n      this.pendingRequests.delete(requestId);\n    }\n\n    // Remove WebSocket message listener\n    this.webSocketManager.removeListener(\n      \"message\",\n      this.handleMessage.bind(this)\n    );\n\n    // Clear all event listeners\n    this.removeAllListeners();\n\n    // Clear auth token\n    this.clearAuthToken();\n\n    // Clear references\n    this.webSocketManager = null!;\n    this.logger = null!;\n    this.pendingRequests = null!;\n  }\n}\n", "import EventEmitter from \"eventemitter3\";\nimport {\n  WebSocketManager,\n  WebSocketState,\n  AuthMethod,\n  IWebSocketAuthConfig,\n} from \"./WebSocketManager\";\nimport { BrowserConsoleStrategy } from \"./BrowserConsoleStrategy\";\nimport { RequestManager } from \"./RequestManager\";\nimport {\n  IResponseData,\n  IRequest,\n  IResponse,\n  IRequestHeader,\n} from \"../interfaces\";\nimport { HeartbeatRequest, HeartbeatResponse } from \"../services\";\n\nexport interface ICommunicationsManagerConfig {\n  url: string;\n  secure?: boolean;\n  auth?: {\n    method: AuthMethod;\n    token?: string;\n    credentials?: {\n      username: string;\n      password: string;\n    };\n  };\n  maxReconnectAttempts?: number;\n  reconnectInterval?: number;\n  heartbeatInterval?: number;\n  requestTimeout?: number;\n}\n\nexport class CommunicationsManager extends EventEmitter {\n  private webSocketManager: WebSocketManager;\n  private requestManager: RequestManager;\n  private logger = new BrowserConsoleStrategy();\n  private config: ICommunicationsManagerConfig;\n  private lastHeartbeatTimestamp: number = 0;\n\n  constructor(config: ICommunicationsManagerConfig) {\n    super();\n    this.config = config;\n    this.validateConfig(config);\n\n    try {\n      this.initializeManagers(config);\n    } catch (error) {\n      this.logger.error(\"Error initializing CommunicationsManager\", { error });\n      throw new Error(\"Failed to initialize CommunicationsManager\");\n    }\n  }\n\n  private initializeManagers(config: ICommunicationsManagerConfig) {\n    this.webSocketManager = new WebSocketManager({\n      url: config.url,\n      secure: config.secure,\n      auth: config.auth,\n      maxReconnectAttempts: config.maxReconnectAttempts,\n      reconnectInterval: config.reconnectInterval,\n    });\n\n    this.requestManager = new RequestManager({\n      webSocketManager: this.webSocketManager,\n      requestTimeout: config.requestTimeout,\n    });\n\n    this.setupWebSocketHooks();\n  }\n\n  private async cleanupCurrentState(): Promise<void> {\n    // Remove event listeners but keep the manager instances\n    this.webSocketManager.removeAllListeners();\n    this.requestManager.removeAllListeners();\n\n    // Close current WebSocket connection\n    if (this.webSocketManager) {\n      await new Promise<void>((resolve) => {\n        this.webSocketManager.once(\"close\", () => resolve());\n        this.webSocketManager.close();\n      });\n    }\n\n    // Clear request manager state\n    if (this.requestManager) {\n      this.requestManager.clearState();\n    }\n  }\n\n  private setupWebSocketHooks() {\n    this.webSocketManager.on(\n      \"maxReconnectAttemptsReached\",\n      this.handleMaxReconnectAttemptsReached.bind(this)\n    );\n\n    this.webSocketManager.on(\"authError\", (error) => {\n      this.logger.error(\"Authentication error\", error);\n      this.emit(\"authError\", error);\n    });\n\n    this.registerMessageHandler(\n      \"heartbeat\",\n      async (heartbeat: HeartbeatRequest, header: IRequestHeader) => {\n        // Emit heartbeat event for monitoring\n        const latency = Date.now() - heartbeat.timestamp;\n        this.lastHeartbeatTimestamp = Date.now();\n        this.emit(\"heartbeat\", { latency });\n\n        return {\n          requestTimestamp: heartbeat.timestamp,\n          responseTimestamp: Date.now(),\n        };\n      }\n    );\n  }\n\n  public async authenticate(authConfig: IWebSocketAuthConfig): Promise<void> {\n    try {\n      await this.cleanupCurrentState();\n\n      // Create new config with authentication\n      const newConfig = {\n        ...this.config,\n        auth: authConfig,\n      };\n\n      // Reinitialize with authenticated config\n      this.initializeManagers(newConfig);\n\n      this.logger.info(\"Switched to authenticated mode\");\n      this.emit(\"modeChanged\", \"authenticated\");\n    } catch (error) {\n      this.logger.error(\"Error switching to authenticated mode\", error);\n      throw error;\n    }\n  }\n\n  public async switchToAnonymous(): Promise<void> {\n    try {\n      // Clear current state but don't destroy everything\n      await this.cleanupCurrentState();\n\n      // Create new config for anonymous connection\n      const anonymousConfig = {\n        ...this.config,\n        auth: {\n          method: AuthMethod.ANONYMOUS,\n        },\n      };\n\n      // Reinitialize with anonymous config\n      this.initializeManagers(anonymousConfig);\n\n      this.logger.info(\"Switched to anonymous mode\");\n      this.emit(\"modeChanged\", \"anonymous\");\n    } catch (error) {\n      this.logger.error(\"Error switching to anonymous mode\", error);\n      throw error;\n    }\n  }\n\n  public onOpen(callback: () => void) {\n    this.logger.info(\"onOpen callback registered\");\n    this.webSocketManager.on(\"open\", callback);\n  }\n\n  public onClose(callback: (event: CloseEvent) => void) {\n    this.logger.info(\"onClose callback registered\");\n    this.webSocketManager.on(\"close\", callback);\n  }\n\n  public onError(callback: (error: Event) => void) {\n    this.logger.info(\"onError callback registered\");\n    this.webSocketManager.on(\"error\", callback);\n  }\n\n  public onMessage(callback: (data: string) => void) {\n    this.logger.info(\"onMessage callback registered\");\n    this.webSocketManager.on(\"message\", callback);\n  }\n\n  private handleMaxReconnectAttemptsReached() {\n    this.logger.error(\n      \"Maximum reconnection attempts reached. To try again, please refresh the page.\"\n    );\n  }\n\n  private validateConfig(config: ICommunicationsManagerConfig): void {\n    if (!config.url) {\n      throw new Error(\"URL is required in the configuration\");\n    }\n  }\n\n  public async request<I, O>(\n    requestType: string,\n    body: I,\n    to?: string\n  ): Promise<IResponseData<O>> {\n    try {\n      return this.requestManager.request(requestType, body, to);\n    } catch (error) {\n      this.logger.error(\"Error making request\", { requestType, error });\n      throw error;\n    }\n  }\n\n  public registerMessageHandler<T, R>(\n    messageType: string,\n    handler: (data: T, header: IRequestHeader) => Promise<R> | R\n  ) {\n    this.requestManager.registerHandler(\n      messageType,\n      async (payload: T, header) => {\n        try {\n          return await handler(payload, header);\n        } catch (error) {\n          // Proper error handling while maintaining the contract\n          throw error instanceof Error ? error : new Error(String(error));\n        }\n      }\n    );\n  }\n\n  public getConnectionState(): WebSocketState {\n    return this.webSocketManager.getState();\n  }\n\n  public updateAuthentication(auth: IWebSocketAuthConfig) {\n    this.webSocketManager.reconnectWithNewAuth(auth);\n  }\n\n  public isAuthenticated(): boolean {\n    return this.webSocketManager.isAuthenticated();\n  }\n\n  public getCurrentMode(): \"anonymous\" | \"authenticated\" {\n    return this.config.auth?.method === AuthMethod.ANONYMOUS\n      ? \"anonymous\"\n      : \"authenticated\";\n  }\n\n  public destroy(): void {\n    this.removeAllListeners();\n\n    if (this.webSocketManager) {\n      this.webSocketManager.destroy();\n      this.webSocketManager = null!;\n    }\n\n    if (this.requestManager) {\n      this.requestManager.destroy();\n      this.requestManager = null!;\n    }\n\n    this.logger = null!;\n    this.config = null!;\n  }\n\n  public getConnectionHealth(): {\n    connected: boolean;\n    lastHeartbeat?: number;\n  } {\n    return {\n      connected: this.webSocketManager.getState() === WebSocketState.OPEN,\n      lastHeartbeat: this.lastHeartbeatTimestamp,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_eventemitter3", "__commonJSMin", "exports", "module", "has", "prefix", "Events", "EE", "fn", "context", "once", "addListener", "emitter", "event", "listener", "evt", "clearEvent", "EventEmitter", "names", "events", "name", "handlers", "i", "l", "ee", "listeners", "a1", "a2", "a3", "a4", "a5", "len", "args", "length", "j", "browser_exports", "__export", "AuthMethod", "BrowserConsoleStrategy", "CommunicationsManager", "WebSocketManager", "WebSocketState", "import_index", "eventemitter3_default", "EventEmitter", "getRandomValues", "rnds8", "rng", "regex_default", "validate", "uuid", "regex_default", "validate_default", "byteToHex", "i", "stringify", "arr", "offset", "uuid", "validate_default", "stringify_default", "v4", "options", "buf", "offset", "rnds", "rng", "i", "stringify_default", "v4_default", "LogStrategy", "_LogStrategy", "message", "options", "truncatedMessage", "packagedMessage", "v4_default", "value", "depth", "maxStringLength", "maxDepth", "item", "truncatedObject", "key", "prop", "_BrowserConsoleStrategy", "LogStrategy", "maxStringLength", "maxDepth", "body", "packagedMessage", "options", "header", "logLevel", "logMessage", "requestId", "sender", "timestamp", "level", "message", "payload", "color", "data", "BrowserConsoleStrategy", "WebSocketState", "AuthMethod", "WebSocketManager", "eventemitter3_default", "config", "BrowserConsoleStrategy", "username", "password", "credentials", "secureUrl", "urlWithAuth", "error", "url", "secure", "wsError", "errorDetails", "event", "parsedData", "delay", "data", "message", "authConfig", "RequestManager", "eventemitter3_default", "props", "BrowserConsoleStrategy", "requestType", "body", "to", "resolve", "reject", "request", "timeoutId", "requestCallback", "response", "v4_default", "parsed", "error", "errorResponse", "pendingRequest", "handler", "payload", "requestHeader", "result", "token", "requestId", "CommunicationsManager", "eventemitter3_default", "config", "BrowserConsoleStrategy", "error", "WebSocketManager", "RequestManager", "resolve", "heartbeat", "header", "latency", "authConfig", "newConfig", "anonymousConfig", "callback", "requestType", "body", "to", "messageType", "handler", "payload", "auth"]
}
